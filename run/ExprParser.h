/* This file was generated by Grammax v1.1.0 */

#ifndef GRAMMAX_PARSER_EXPRPARSER_H
#define GRAMMAX_PARSER_EXPRPARSER_H

#include <vector>

class ExprParser {
private:
#define T_MUL 0
#define T_NUM 1
#define T_LPAREN 2
#define T_RPAREN 3
#define T_PLUS 4
#define T_EOF 5
#define TERMINAL_COUNT 6
#define NON_TERMINAL_COUNT 3
    static constexpr int gotoTable[] = {
        4,3,5,
        4,7,5,
        0,0,0,
        0,0,0,
        0,0,0,
        0,0,0,
        0,0,0,
        11,0,5,
        0,0,12,
        0,0,0,
        0,0,0,
        0,0,0};
    static constexpr int actionTable[] = {
        0,6,2,0,0,0,
        0,6,2,0,0,0,
        0,0,0,0,8,-1,
        9,0,0,-3,-3,-3,
        -5,0,0,-5,-5,-5,
        -7,0,0,-7,-7,-7,
        0,0,0,10,8,0,
        0,6,2,0,0,0,
        0,6,2,0,0,0,
        -6,0,0,-6,-6,-6,
        9,0,0,-2,-2,-2,
        -4,0,0,-4,-4,-4};
    static constexpr int productionLabels[] = {1,1,0,0,2,2};
public:
    union StackEntryPayload {
        void* _grx_object;
        int t;
        int e;
        int f;
        int NUM;
    };
private:
    struct StackEntry {
        int previousState;
        StackEntryPayload payload;
        StackEntry(int previousState, StackEntryPayload payload) : previousState(previousState), payload(payload) {}
        StackEntry() : previousState(0), payload({._grx_object = nullptr}) {}
    };
    static StackEntryPayload _reduction0(std::vector<StackEntry>* _grx_stack) {
        int term = _grx_stack->back().payload.t;
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        int expr = _grx_stack->back().payload.e;
        _grx_stack->pop_back();
        int v;
        {
         v = expr + term; 
        }
        StackEntryPayload _grx_v = {.e = v};
        return _grx_v;
    }
    static StackEntryPayload _reduction1(std::vector<StackEntry>* _grx_stack) {
        int term = _grx_stack->back().payload.t;
        _grx_stack->pop_back();
        int v;
        {
         v = term; 
        }
        StackEntryPayload _grx_v = {.e = v};
        return _grx_v;
    }
    static StackEntryPayload _reduction2(std::vector<StackEntry>* _grx_stack) {
        int factor = _grx_stack->back().payload.f;
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        int term = _grx_stack->back().payload.t;
        _grx_stack->pop_back();
        int v;
        {
         v = term * factor; 
        }
        StackEntryPayload _grx_v = {.t = v};
        return _grx_v;
    }
    static StackEntryPayload _reduction3(std::vector<StackEntry>* _grx_stack) {
        int factor = _grx_stack->back().payload.f;
        _grx_stack->pop_back();
        int v;
        {
         v = factor; 
        }
        StackEntryPayload _grx_v = {.t = v};
        return _grx_v;
    }
    static StackEntryPayload _reduction4(std::vector<StackEntry>* _grx_stack) {
        _grx_stack->pop_back();
        int expr = _grx_stack->back().payload.e;
        _grx_stack->pop_back();
        _grx_stack->pop_back();
        int v;
        {
         v = expr; 
        }
        StackEntryPayload _grx_v = {.f = v};
        return _grx_v;
    }
    static StackEntryPayload _reduction5(std::vector<StackEntry>* _grx_stack) {
        int n = _grx_stack->back().payload.NUM;
        _grx_stack->pop_back();
        int v;
        {
         v = n; 
        }
        StackEntryPayload _grx_v = {.f = v};
        return _grx_v;
    }
    static constexpr StackEntryPayload (*reductions[])(std::vector<StackEntry>*) = {_reduction0, _reduction1, _reduction2, _reduction3, _reduction4, _reduction5};

    std::vector<StackEntry> stack;
    StackEntryPayload payload;
    bool payloadInitialized = false;
public:
    ExprParser() {
        stack.emplace_back();
    }
    void reset() {
        stack.clear();
        stack.emplace_back();
        payloadInitialized = false;
    }
    bool parse(int tokenId, StackEntryPayload tokenPayload) {
        while (true) {
            int action = actionTable[TERMINAL_COUNT * stack.back().previousState + tokenId];
            if (action == 0) {
                return false;
            }
            if (action == -1) {
                payload = stack.back().payload;
                payloadInitialized = true;
                return true;
            }
            if (action > 0) {
                stack.emplace_back(action - 1, tokenPayload);
                return true;
            }
            const int productionIndex = -action - 2;
            const StackEntryPayload reducedProduction = reductions[productionIndex](&stack);
            const StackEntry newState = stack.back();
            const int nextState = gotoTable[newState.previousState * NON_TERMINAL_COUNT + productionLabels[productionIndex]];
            stack.emplace_back(nextState - 1, reducedProduction);
        }
    }
    [[nodiscard]] bool successfullyParsed() const {
        return payloadInitialized;
    }
    [[nodiscard]] StackEntryPayload getValue() const {
        return payload;
    }
};

#endif
